# Как CI/CD помогает разработке через Cursor AI

## Обзор

Этот документ объясняет, как автоматизированный CI/CD процесс для сборки `Tor.xcframework` улучшает разработку с использованием Cursor AI.

---

## Проблема, которую решает CI/CD

### До CI/CD (старый подход):

1. **Ручная сборка каждый раз:**
   ```bash
   # Вы делаете изменения в коде
   # Запускаете скрипты сборки локально (30-60 минут)
   # Тестируете локально
   # Коммитите XCFramework вручную
   # Обновляете тег
   ```

2. **Проблемы для Cursor AI:**
   - ❌ Cursor AI не может проверить работоспособность без длительной локальной сборки
   - ❌ Нет автоматической проверки что патч применён
   - ❌ Нет гарантии что XCFramework собран правильно (без header pollution)
   - ❌ Сложно отследить какие изменения сломали сборку

### После CI/CD (новый подход):

1. **Автоматическая сборка:**
   ```bash
   # Вы делаете изменения в коде
   git tag v1.0.XX
   git push origin v1.0.XX
   # CI/CD автоматически собирает XCFramework
   # Проверяет структуру
   # Коммитит результат
   ```

2. **Преимущества для Cursor AI:**
   - ✅ Cursor AI может предложить изменения, зная что они будут проверены автоматически
   - ✅ Автоматическая проверка патча перед сборкой(m не соберётся если патча нет)
   - ✅ Гарантия правильной структуры XCFramework (проверка в workflow)
   - ✅ История успешных/неуспешных сборок для анализа

---

## Как CI/CD помогает Cursor AI в разработке

### 1. **Автоматическая валидация изменений**

**Сценарий:**
Вы просите Cursor AI изменить код в `Package.swift` или добавить новый exclude файл.

**Что происходит:**
1. Cursor AI предлагает изменения
2. Вы коммитите и создаёте тег
3. CI/CD автоматически проверяет:
   - ✅ Патч присутствует
   - ✅ XCFramework собирается без ошибок
   - ✅ Структура правильная (нет header pollution)
4. Если что-то сломано - CI/CD сразу покажет ошибку

**Без CI/CD:**
- Пришлось бы запускать локальную сборку (30-60 минут)
- Cursor AI не знает сразу, работают ли изменения

**С CI/CD:**
- Cursor AI может предложить изменения, зная что они будут проверены
- Вы видите результат через 30-60 минут автоматически

---

### 2. **Контекст для Cursor AI из истории сборок**

**Сценарий:**
Вы спрашиваете Cursor AI: "Почему последняя сборка не удалась?"

**Что происходит:**
1. Cursor AI видит логи GitHub Actions в контексте репозитория
2. Может проанализировать:
   - Какие изменения были в последнем коммите
   - Какая именно проверка упала
   - Какие файлы были изменены

**Пример:**
```
❌ ERROR: OpenSSL headers found in public Headers/!
```

Cursor AI понимает:
- Это ошибка из шага "Verify XCFramework structure"
- Значит скрипт `build_correct_xcframework.sh` скопировал лишние headers
- Нужно проверить этот скрипт

---

### 3. **Быстрая итерация с обратной связью**

**Сценарий:**
Вы меняете `orconfig.h` и хотите проверить что это не сломало сборку.

**Без CI/CD:**
```bash
# Локальная сборка (30-60 минут)
bash scripts/direct_build.sh
bash scripts/build_tor_simulator.sh
bash scripts/build_correct_xcframework.sh
# Проверка результата...
```

**С CI/CD:**
```bash
# Создать тег (5 секунд)
git tag v1.0.99-test
git push origin v1.0.99-test
# CI/CD собирает автоматически
# Через 30-60 минут видите результат в GitHub Actions
```

**Польза для Cursor AI:**
- Cursor AI может предложить несколько вариантов изменений
- Вы можете протестировать все автоматически через CI/CD
- Не нужно ждать локальную сборку для каждого варианта

---

### 4. **Воспроизводимость и документация**

**Сценарий:**
Через месяц вы хотите понять, как был собран конкретный XCFramework.

**Что происходит:**
1. Cursor AI видит в истории:
   - Какой тег использовался (`v1.0.50`)
   - Какие скрипты выполнялись (из workflow)
   - Какие проверки прошли успешно
   - Логи сборки

2. Cursor AI может объяснить:
   - "Этот XCFramework был собран из тега v1.0.50"
   - "Проверка патча прошла успешно"
   - "Структура XCFramework правильная (нет header pollution)"

**Без CI/CD:**
- Нужно искать в локальной истории
- Непонятно, какая версия скриптов использовалась
- Нет гарантии что результат воспроизводим

---

### 5. **Автоматическое тестирование интеграции**

**Сценарий:**
Вы обновляете версию Tor в `Package.swift` и хотите проверить что TorApp всё ещё работает.

**Что происходит:**
1. CI/CD собирает новый XCFramework
2. Вы обновляете версию в TorApp
3. Cursor AI может предложить автоматический тест:
   ```bash
   cd ~/admin/TorApp
   tuist fetch --update
   tuist build
   ```

**Расширенный вариант (можно добавить в CI/CD):**
```yaml
- name: Test integration with TorApp
  run: |
    # Клонировать TorApp
    git clone https://github.com/.../TorApp.git test-torapp
    cd test-torapp
    # Обновить версию TorFrameworkBuilder
    # Запустить tuist build
    # Проверить что нет ошибок dns_sd.h
```

Cursor AI может предложить такой шаг, зная что это улучшит автоматизацию.

---

## Практические примеры использования с Cursor AI

### Пример 1: Обновление версии Tor

**Вы:**
> "Обнови версию Tor до 0.4.8.20 в Package.swift"

**Cursor AI:**
1. Находит где указана версия (в комментариях, README, etc.)
2. Предлагает изменения
3. Может предложить: "После этого создайте тег `v1.0.XX` для автоматической сборки"

**Вы:**
```bash
git tag v1.0.100
git push origin v1.0.100
```

**CI/CD:**
- Автоматически собирает новый XCFramework
- Проверяет что всё работает
- Коммитит результат

---

### Пример 2: Исправление ошибки сборки

**Ситуация:**
CI/CD показывает ошибку: `❌ ERROR: OpenSSL headers found in public Headers/!`

**Вы спрашиваете Cursor AI:**
> "Почему CI/CD находит OpenSSL headers в Headers/?"

**Cursor AI:**
1. Анализирует workflow файл
2. Находит шаг проверки
3. Анализирует скрипт `build_correct_xcframework.sh`
4. Находит проблему: возможно скрипт всё ещё копирует OpenSSL headers

**Cursor AI предлагает:**
```bash
# Проверить строки 140-143 в build_correct_xcframework.sh
# Убедиться что команды копирования OpenSSL закомментированы
```

**Вы:**
- Исправляете скрипт
- Коммитите
- Создаёте новый тег
- CI/CD проверяет что проблема решена

---

### Пример 3: Добавление новой проверки

**Вы:**
> "Добавь проверку что XCFramework не превышает 50MB"

**Cursor AI:**
1. Анализирует workflow файл
2. Находит шаг "Verify XCFramework structure"
3. Предлагает добавить проверку размера:

```yaml
- name: Verify XCFramework size
  run: |
    SIZE=$(du -m output/Tor.xcframework | cut -f1)
    if [ $SIZE -gt 50 ]; then
      echo "❌ ERROR: XCFramework too large: ${SIZE}MB (max 50MB)"
      exit 1
    fi
    echo "✅ XCFramework size OK: ${SIZE}MB"
```

**Польза:**
- Cursor AI понимает структуру workflow
- Может предложить правильные проверки
- После добавления - проверка работает автоматически

---

## Настройка автоматического запуска

### В GitHub репозитории:

1. **Settings → Actions → General:**
   - ✅ "Allow all actions and reusable workflows"
   - ✅ "Allow actions to create and approve pull requests"
   - ✅ "Workflow permissions: Read and write permissions"

2. **Settings → Actions → Runners:**
   - Убедитесь что есть доступные macOS runners (GitHub предоставляет автоматически)

3. **После первого успешного запуска:**
   - Workflow будет запускаться автоматически при создании тега
   - Не требуется ручное одобрение

---

## FAQ

### Q: Почему workflow не запускается автоматически?

**A:** Проверьте:
1. Настройки репозитория (см. выше)
2. Что тег создан правильно: `git tag v1.0.99` (не `1.0.99`)
3. Что тег запушен: `git push origin v1.0.99`
4. Что файл workflow находится в `.github/workflows/` и закоммичен

### Q: Можно ли запустить workflow вручную?

**A:** Да! В GitHub UI:
1. Откройте вкладку "Actions"
2. Выберите workflow "Build XCFramework"
3. Нажмите "Run workflow"
4. Выберите ветку и нажмите "Run workflow"

### Q: Как Cursor AI узнает о результатах сборки?

**A:** Cursor AI может:
1. Читать логи GitHub Actions (если у него есть доступ к репозиторию)
2. Анализировать файлы в репозитории (workflow файлы, скрипты)
3. Видеть историю коммитов и тегов

### Q: Можно ли добавить уведомления о результатах сборки?

**A:** Да! Можно добавить в workflow:
```yaml
- name: Notify on failure
  if: failure()
  uses: actions/github-script@v6
  with:
    script: |
      // Отправить уведомление в Slack/Email/etc.
```

---

## Итог

CI/CD делает разработку с Cursor AI более эффективной потому что:

1. ✅ **Автоматическая проверка** - не нужно ждать локальную сборку
2. ✅ **История и контекст** - Cursor AI видит что работает, а что нет
3. ✅ **Быстрая итерация** - можно тестировать изменения автоматически
4. ✅ **Воспроизводимость** - всегда понятно как был собран XCFramework
5. ✅ **Надёжность** - гарантия правильной структуры без header pollution

**Результат:** Cursor AI может предложить изменения, зная что они будут автоматически проверены, что ускоряет разработку и снижает риск ошибок.

